//
// AUTO-GENERATED FILE, DO NOT MODIFY!
//
// @dart=2.0

// ignore_for_file: unused_element, unused_import
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: constant_identifier_names
// ignore_for_file: lines_longer_than_80_chars

part of polaris;

class PredictionLookupRequest {
  /// Returns a new [PredictionLookupRequest] instance.
  PredictionLookupRequest({
    @required this.requestId,
    @required this.id,
    @required this.language,
    @required this.sessionToken,
  });

  /// UUID v4 for the request, generated by the caller at the time of the request
  String requestId;

  /// Prediction candidate ID from earlier search result in same autocomplete session or freeform search text. Use the description from an earlier search result for the best chance of having useful details returned. 
  String id;

  /// The ISO 639-1 code of the input and (preferred) output language. Note: The service does not currently distinguish between regional differences in languages, as captured by the IETF Language Tag standard At the time of writing the supported values were: en, es and th References: - https://en.wikipedia.org/wiki/IETF_language_tag - https://en.wikipedia.org/wiki/ISO_639 
  String language;

  /// A string containing a UUID v4 generated by the caller. This token is used to group search requests with  requests to fetch the details of a candidate result.  If no active token exists, the caller should generate one and use it until it becomes \"consumed\". A token becomes consumed once a call is made to fetch the details for a candidate result. The token must no longer be  used for subsequent searches, even if they are further refinements of the current search string. NOTE: Reusing a token for unrelated searches and/or place detail lookups has undefined behaviour. 
  String sessionToken;

  @override
  bool operator ==(Object other) => identical(this, other) || other is PredictionLookupRequest &&
     other.requestId == requestId &&
     other.id == id &&
     other.language == language &&
     other.sessionToken == sessionToken;

  @override
  int get hashCode =>
  // ignore: unnecessary_parenthesis
    (requestId == null ? 0 : requestId.hashCode) +
    (id == null ? 0 : id.hashCode) +
    (language == null ? 0 : language.hashCode) +
    (sessionToken == null ? 0 : sessionToken.hashCode);

  @override
  String toString() => 'PredictionLookupRequest[requestId=$requestId, id=$id, language=$language, sessionToken=$sessionToken]';

  Map<String, dynamic> toJson() {
    final json = <String, dynamic>{};
      json[r'requestId'] = requestId;
      json[r'id'] = id;
      json[r'language'] = language;
      json[r'sessionToken'] = sessionToken;
    return json;
  }

  /// Returns a new [PredictionLookupRequest] instance and imports its values from
  /// [value] if it's a [Map], null otherwise.
  // ignore: prefer_constructors_over_static_methods
  static PredictionLookupRequest fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();
      return PredictionLookupRequest(
        requestId: mapValueOfType<String>(json, r'requestId'),
        id: mapValueOfType<String>(json, r'id'),
        language: mapValueOfType<String>(json, r'language'),
        sessionToken: mapValueOfType<String>(json, r'sessionToken'),
      );
    }
    return null;
  }

  static List<PredictionLookupRequest> listFromJson(dynamic json, {bool emptyIsNull, bool growable,}) =>
    json is List && json.isNotEmpty
      ? json.map(PredictionLookupRequest.fromJson).toList(growable: true == growable)
      : true == emptyIsNull ? null : <PredictionLookupRequest>[];

  static Map<String, PredictionLookupRequest> mapFromJson(dynamic json) {
    final map = <String, PredictionLookupRequest>{};
    if (json is Map && json.isNotEmpty) {
      json
        .cast<String, dynamic>()
        .forEach((key, dynamic value) => map[key] = PredictionLookupRequest.fromJson(value));
    }
    return map;
  }

  // maps a json object with a list of PredictionLookupRequest-objects as value to a dart map
  static Map<String, List<PredictionLookupRequest>> mapListFromJson(dynamic json, {bool emptyIsNull, bool growable,}) {
    final map = <String, List<PredictionLookupRequest>>{};
    if (json is Map && json.isNotEmpty) {
      json
        .cast<String, dynamic>()
        .forEach((key, dynamic value) {
          map[key] = PredictionLookupRequest.listFromJson(
            value,
            emptyIsNull: emptyIsNull,
            growable: growable,
          );
        });
    }
    return map;
  }
}

